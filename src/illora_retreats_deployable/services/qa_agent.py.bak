# qa_agent.py

from typing import Optional, List, Dict, Any
from langchain_openai import ChatOpenAI
from vector_store import create_vector_store
from config import Config
from logger import setup_logger
import os
import json
import requests
import time
import re
import difflib
from datetime import datetime

logger = setup_logger("QAAgent")


def _normalize_text(s: str) -> str:
    """Normalize text for comparison."""
    if not s:
        return ""
    s = s.lower()
    s = re.sub(r"[^a-z0-9\s]", " ", s)
    s = re.sub(r"\s+", " ", s).strip()
    return s


class ConciergeBot:
    """Extended ConciergeBot with pre-checkin / checkin flow."""

    def __init__(self):
        try:
            # Chat history storage
            self.chat_history = {}  # Dictionary to store chat history by session ID
            
            # Google Sheets endpoint (Apps Script deprecated) â€” prefer gsheets helper
            self.sheet_api = getattr(Config, "GSHEET_WEBAPP_URL", "")

            # Sheet/tab names
            self.qna_sheet = getattr(Config, "GSHEET_QNA_SHEET", "QnA_Manager")
            self.dos_sheet = getattr(Config, "GSHEET_DOS_SHEET", "Dos and Donts")
            self.campaign_sheet = getattr(Config, "GSHEET_CAMPAIGN_SHEET", "Campaigns_Manager")
            self.menu_sheet = getattr(Config, "GSHEET_MENU_SHEET", "menu_manager")
            self.client_sheet = getattr(Config, "GSHEET_CLIENT_SHEET", "Client_workflow")

            # Retriever params
            self.retriever_k = getattr(Config, "RETRIEVER_K", 5)
            self.total_rooms = getattr(Config, "TOTAL_ROOMS", 14)
            # Prefer using direct Google Sheets access via the helper by default
            self.use_sheet = True

            # LLM setup
            if Config.LLM_PROVIDER == "openai":
                self.llm = ChatOpenAI(
                    api_key=Config.OPENAI_API_KEY,
                    model=Config.OPENAI_MODEL,
                    temperature=0,
                )
            else:  # Groq
                self.llm = ChatOpenAI(
                    api_key=Config.GROQ_API_KEY,
                    model=Config.GROQ_MODEL,
                    base_url=Config.GROQ_API_BASE,
                    temperature=0,
                )

            # Storage
            self.qna_rows: List[Dict[str, Any]] = []
            self.dos_donts: List[Dict[str, str]] = []
            self.campaigns: List[Dict[str, Any]] = []
            self.menu_rows: List[Dict[str, Any]] = []
            self.client_rows: List[Dict[str, Any]] = []

            if self.use_sheet:
                try:
                    self._refresh_sheets()
                    logger.info("Loaded QnA / Dos & Donts / Campaigns / Clients from Google Sheets web app.")
                except Exception as e:
                    logger.warning(f"Could not load sheets on init: {e}. Falling back to vector store if available.")
                    self.use_sheet = False

            if not self.use_sheet:
                try:
                    self.vector_store = create_vector_store()
                    k = getattr(Config, "RETRIEVER_K", 5)
                    fetch_k = getattr(Config, "RETRIEVER_FETCH_K", 20)
                    self.retriever = self.vector_store.as_retriever(
                        search_type="mmr", search_kwargs={"k": k, "fetch_k": fetch_k}
                    )
                    logger.info("FAISS vector store loaded as fallback retriever.")
                except Exception as e:
                    logger.error(f"Error initializing vector store fallback: {e}")
                    self.retriever = None

            # Load Do's & Don'ts from file if no sheet data
            if not self.dos_donts:
                self.dos_donts_path = os.path.join("data", "dos_donts.json")
                self.dos_donts = self._load_dos_donts_from_file()

            logger.info("ILORA RETREATS QA agent initialized successfully.")

        except Exception as e:
            logger.error(f"Error initializing QA agent: {e}")
            raise

    def _fetch_sheet_data(self, sheet_name: str) -> List[Dict[str, Any]]:
        """Fetch data from Google Sheet."""
        if not self.sheet_api:
            raise RuntimeError("GSHEET_WEBAPP_URL is not configured in Config.")
        params = {"action": "getSheetData", "sheet": sheet_name}
        try:
            resp = requests.get(self.sheet_api, params=params, timeout=15)
            resp.raise_for_status()
            data = resp.json()
            if isinstance(data, dict) and data.get("error"):
                raise RuntimeError(f"Sheets webapp returned error: {data.get('error')}")
            if not isinstance(data, list):
                raise RuntimeError("Unexpected sheet response format (expected list of row objects).")
            return data
        except Exception as e:
            logger.error(f"Error fetching sheet '{sheet_name}' from {self.sheet_api}: {e}")
            raise

    def _refresh_sheets(self):
        """Refresh all sheet data."""
        self.qna_rows = self._fetch_sheet_data(self.qna_sheet) or []
        raw_dos = self._fetch_sheet_data(self.dos_sheet) or []
        processed = []
        for row in raw_dos:
            do_val = row.get("Do") or row.get("do") or row.get("Do's") or row.get("Do_s") or row.get("Do / Don't") or ""
            dont_val = row.get("Don't") or row.get("Dont") or row.get("dont") or row.get("Don'ts") or row.get("Dont_s") or ""
            processed.append({"do": str(do_val).strip(), "dont": str(dont_val).strip()})
        self.dos_donts = processed
        self.campaigns = self._fetch_sheet_data(self.campaign_sheet) or []
        self.menu = self._fetch_sheet_data(self.menu_sheet) or []
        self.client_rows = self._fetch_sheet_data(self.client_sheet) or []

    def _load_dos_donts_from_file(self) -> List[Dict[str, str]]:
        """Load dos and don'ts from file."""
        path = getattr(self, "dos_donts_path", os.path.join("data", "dos_donts.json"))
        if not os.path.exists(path):
            return []
        try:
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            logger.warning(f"Failed to load Do's & Don'ts file: {e}")
            return []

    def _find_client_row(self, identifier: str) -> Optional[Dict[str, Any]]:
        """Find client in sheet data."""
        if not identifier or not self.client_rows:
            return None
        iid = identifier.strip().lower()
        for row in self.client_rows:
            client_id = str(row.get("Client Id") or "").strip().lower()
            username = str(row.get("Username") or row.get("Email") or "").strip().lower()
            booking_id = str(row.get("Booking Id") or "").strip().lower()
            name = str(row.get("Name") or "").strip().lower()
            if iid and (iid == client_id or iid == username or iid == booking_id or iid == name):
                return row
        return None

    def _is_user_booked(self, client_row: Dict[str, Any]) -> bool:
        """Check if user has an active booking."""
        if not client_row:
            return False

        logger.info(f"Checking booking status for client row: {client_row}")
        
        # Primary check: Workflow Stage status
        wf = str(client_row.get("Workfow Stage") or 
                client_row.get("Workflow Stage") or 
                client_row.get("WorkFlow") or "").strip().lower()
        
        # If Workflow Stage is "Confirmed", user is definitely booked
        if wf == "confirmed":
            logger.info("Found Confirmed workflow stage - User is booked")
            return True

        # Secondary checks if Workflow Stage isn't explicitly "Confirmed"
        booking_id = str(client_row.get("Booking Id") or "").strip().lower()
        if booking_id and booking_id not in ["-", "none", "", "n/a"]:
            logger.info(f"Found valid booking ID: {booking_id}")
            return True

        room = str(client_row.get("Room Alloted") or "").strip()
        if room and room not in ["-", "none", "", "n/a"]:
            logger.info(f"Found room allocation: {room}")
            return True

        logger.info("No active booking indicators found")
        return False

    def _is_id_verified(self, client_row: Dict[str, Any]) -> bool:
        """Check if user's ID is verified."""
        if not client_row:
            return False
        v = client_row.get("Id Link") or client_row.get("ID Link") or "none"
        if not v:
            return False
        sval = str(v).strip().lower()
        if sval == "done":
            logger.info("ID verification is marked as DONE")
            return True
        return False

    def _get_chat_history_key(self, client_row: Optional[Dict[str, Any]], user_identifier: Optional[str] = None) -> str:
        """Get a consistent key for chat history storage."""
        if client_row and client_row.get('Client Id'):
            key = client_row['Client Id']
            logger.info(f"Using Client Id as chat key: {key}")
            return key
        elif user_identifier:
            key = f"user_{user_identifier}"
            logger.info(f"Using user identifier as chat key: {key}")
            return key
        else:
            key = f"session_{int(time.time())}"
            logger.info(f"Using temporary session ID: {key}")
            return key

    def _retrieve_from_sheets(self, query: str, k: int = 5) -> List[Dict[str, str]]:
        """Retrieve relevant documents from sheet data."""
        results = []
        query_normalized = _normalize_text(query)

        # Search QnA rows
        for row in self.qna_rows:
            q = str(row.get("Question") or "").strip()
            a = str(row.get("Answer") or "").strip()
            if q and a:
                q_normalized = _normalize_text(q)
                similarity = difflib.SequenceMatcher(None, query_normalized, q_normalized).ratio()
                if similarity > 0.6 or query_normalized in q_normalized:
                    results.append({
                        "page_content": f"Q: {q}\nA: {a}",
                        "similarity": similarity
                    })

        # Sort by similarity and take top k
        results.sort(key=lambda x: x["similarity"], reverse=True)
        return results[:k]

    def _build_prompt(self, hotel_data: str, query: str, session_id: str = None, is_booked: bool = False, is_verified: bool = False) -> str:
        """Build the prompt for LLM."""
        agent_name = "AI Assistant"
        agents_file = os.path.join("data", "agents.json")
        try:
            if os.path.exists(agents_file):
                with open(agents_file, "r", encoding="utf-8") as f:
                    agents = json.load(f)
                for agent in agents:
                    if agent.get("Name") == "Front Desk":
                        agent_name = agent.get("agent_name", agent_name)
        except Exception:
            pass

        # Get chat history for context
        chat_history_text = ""
        if session_id and session_id in self.chat_history:
            logger.info("\n=== Complete Chat History ===")
            logger.info(f"History Key: {session_id}")
            for idx, msg in enumerate(self.chat_history[session_id], 1):
                logger.info(f"{idx}. {msg['role'].upper()}: {msg['text']}")
                logger.info(f"   Timestamp: {msg['timestamp']}")
            logger.info("==========================\n")

            # Add recent history to prompt
            chat_history_text = "\nPrevious conversation context:\n"
            current_time = datetime.utcnow().isoformat()
            prev_messages = [msg for msg in self.chat_history[session_id] if msg['timestamp'] != current_time]
            for msg in prev_messages[-5:]:
                chat_history_text += f"{'User' if msg['role'] == 'user' else 'Assistant'}: {msg['text']}\n"
            
            logger.info("\n=== Chat History Added to Prompt ===")
            logger.info(chat_history_text)
            logger.info("===================================\n")

        # Build main prompt
        prompt = (
            f"You are an AI agent named {agent_name}, a knowledgeable, polite, and concise concierge assistant at *ILORA RETREATS*, "
            "a premium hotel known for elegant accommodations, gourmet dining, rejuvenating spa treatments, "
            "a fully-equipped gym, pool access, 24x7 room service, meeting spaces, and personalized hospitality.\n\n"
        )

        if not is_booked or not is_verified:
            prompt += (
                "Answer most questions using the Hotel Data given below. If the data does not contain the answer you can draw on general knowledge, "
                "DO NOT ANSWER ANYTHING RELATED TO IN-ROOM SERVICES, SPA BOOKINGS, OR AMENITY ACCESS. "
                "For these services, politely inform that a confirmed booking and ID verification are required.\n\n"
                f"Agent Name:\n{agent_name}\n\n"
                f"Hotel Data (most relevant excerpts):\n{hotel_data}\n\n"
                f"Verification Status: {'Not Booked' if not is_booked else 'Booked but ID Not Verified'}\n\n"
                f"{chat_history_text}\n"
                "Guest Query: " + query + "\n"
            )
        else:
            prompt += (
                "Answer most questions using the Hotel Data. If data doesn't contain the answer you can draw on general knowledge, but remember:\n"
                "1. DO NOT MAKE ANY FALSE FACTS\n"
                "2. DO NOT ASK FOR ROOM NUMBER\n"
                "3. DO NOT GIVE THE BOOKING FORM AT ANY COST\n"
                "4. For wake-up calls, ask for the specific time if not provided\n"
                "5. Handle all in-room service requests directly\n"
                "6. Create service tickets automatically for guest requests\n\n"
                f"Agent Name:\n{agent_name}\n\n"
                f"Hotel Data (most relevant excerpts):\n{hotel_data}\n\n"
                f"{chat_history_text}\n"
                "Guest Query: " + query + "\n"
            )

        return prompt

    def ask(self, query: str, user_type: Optional[str] = None, user_identifier: Optional[str] = None, frontend_action: Optional[Dict[str, Any]] = None) -> Any:
        """Process user query and return response."""
        try:
            if self.use_sheet:
                try:
                    self._refresh_sheets()
                except Exception as e:
                    logger.warning(f"Could not refresh sheets at ask(): {e}")

            # Identify client if provided
            client_row = None
            if user_identifier:
                client_row = self._find_client_row(user_identifier)
                logger.info(f"Found client row for {user_identifier}: {client_row}")

            # Get chat history key and ensure history exists
            chat_history_key = self._get_chat_history_key(client_row, user_identifier)
            if chat_history_key not in self.chat_history:
                self.chat_history[chat_history_key] = []
                logger.info(f"Created new chat history with key: {chat_history_key}")

            # Add user message to history immediately
            self.chat_history[chat_history_key].append({
                "role": "user",
                "text": query,
                "timestamp": datetime.utcnow().isoformat()
            })

            # Get booking status
            is_booked = False
            id_verified = False
            if client_row:
                is_booked = self._is_user_booked(client_row)
                id_verified = self._is_id_verified(client_row)
                logger.info(f"User status - Booked: {is_booked}, ID Verified: {id_verified}")

            # Get docs and build prompt
            docs = self._retrieve_from_sheets(query, k=self.retriever_k) if self.use_sheet else []
            hotel_data = "\n\n".join(d['page_content'] for d in docs) if docs else ""
            
            # Generate response
            system_prompt = self._build_prompt(
                hotel_data,
                query,
                session_id=chat_history_key,
                is_booked=is_booked,
                is_verified=id_verified
            )

            response = self.llm.invoke(system_prompt)
            final_answer = response.content.strip() if hasattr(response, "content") else str(response)

            # Add assistant response to history
            self.chat_history[chat_history_key].append({
                "role": "assistant",
                "text": final_answer,
                "timestamp": datetime.utcnow().isoformat()
            })

            # Trim history if needed
            if len(self.chat_history[chat_history_key]) > 50:
                self.chat_history[chat_history_key] = self.chat_history[chat_history_key][-50:] 

            logger.info(f"Processed query at ILORA RETREATS: {query}")
            return final_answer

        except Exception as e:
            import traceback
            logger.error(f"Error processing query at ILORA RETREATS '{query}': {e}")
            logger.error(f"Full traceback: {traceback.format_exc()}")
            return "We're sorry, there was an issue while assisting you. Please try again."