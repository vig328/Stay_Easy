import os
import uuid
import json
import random
import logging
import asyncio
import requests
from typing import List, Optional, Dict, Any, Generator
from datetime import date, datetime, timedelta

from fastapi import FastAPI, Depends, UploadFile, File, HTTPException, Query, Request, Body
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel, Field
from config import Config

# ------------------------- Logging setup -------------------------
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ------------------------- FastAPI app -------------------------
app = FastAPI(title="AI Chieftain API", version="1.0.0")

# ------------------------- CORS -------------------------
FRONTEND_ORIGINS = [
    "http://localhost:8080",
    "http://localhost:3000",
    "http://localhost:5173",
    "http://127.0.0.1:5173",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=FRONTEND_ORIGINS,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allow_headers=["*"],
    expose_headers=["*"],
)

# ------------------------- Google Sheets Configuration -------------------------
GSHEET_WEBAPP_URL = getattr(Config, "GSHEET_WEBAPP_URL", None)
if not GSHEET_WEBAPP_URL:
    raise RuntimeError("GSHEET_WEBAPP_URL not configured in Config")

# ------------------------- Helper Functions -------------------------
def push_row_to_sheet(sheet_name: str, row_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Call Apps Script webapp to add a row to the specified sheet
    """
    logger.info(f"Pushing data to sheet {sheet_name}: {row_data}")
    payload = {"action": "addRow", "sheet": sheet_name, "rowData": row_data}
    
    try:
        resp = requests.post(GSHEET_WEBAPP_URL, json=payload, timeout=10)
        resp.raise_for_status()
        try:
            return resp.json()
        except ValueError:
            if resp.status_code == 200:
                return {"success": True, "status_code": 200}
            return {"success": False, "message": "Invalid JSON response"}
    except requests.exceptions.RequestException as e:
        logger.error(f"Error pushing to sheet: {e}")
        return {"success": False, "message": str(e)}

# ------------------------- Auth Models -------------------------
class SignupReq(BaseModel):
    name: str = Field(..., min_length=2, description="User's full name")
    username: str = Field(..., min_length=3, description="User's email address")
    password: str = Field(..., min_length=6, description="User's password")
    phoneNo: str = Field(default="", description="User's phone number")

# ------------------------- Auth Endpoints -------------------------
@app.post("/auth/signup", tags=["authentication"])
async def signup(req: SignupReq = Body(...)):
    """
    Register a new user and add them to the Client_workflow sheet
    """
    logger.info(f"Received signup request for username: {req.username}")
    
    try:
        # Generate unique Client Id (e.g., ILR-YYYY-XXXX)
        client_id = f"ILR-{datetime.utcnow().year}-{random.randint(1000,9999)}"
        workflow_stage = "Registered"
        
        # Prepare row data for Client_workflow sheet
        row_data = {
            "Client Id": client_id,
            "Name": req.name,
            "Username": req.username,
            "Password": req.password,
            "Booking Id": "",
            "Workflow Stage": workflow_stage,  # Fixed typo in key name
            "Room Alloted": "",
            "CheckIn": "",
            "Check Out": "",
            "Id Link": "",
        }
        
        # Add user to Google Sheet
        resp = push_row_to_sheet("Client_workflow", row_data)
        
        if resp.get("success") or resp.get("ok") or resp.get("status_code") == 200:
            logger.info(f"User {req.username} registered successfully with client ID {client_id}")
            return {
                "success": True,
                "workflowStage": workflow_stage,
                "clientId": client_id,
                "message": "Registration successful"
            }
        else:
            error_msg = resp.get("message", "Unknown error during registration")
            logger.error(f"Failed to register user {req.username}: {error_msg}")
            raise HTTPException(status_code=400, detail=error_msg)
            
    except Exception as e:
        logger.error(f"Error in signup endpoint: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
from fastapi import Body

# ...existing code...


# ...existing code...



import os
import uuid
import json
import random
import logging
import asyncio
from typing import List, Optional, Dict, Any
from datetime import date, datetime, timedelta

from fastapi import FastAPI, Depends, UploadFile, File, HTTPException, Query, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel, Field
from config import Config

# Project imports
import web_ui_final as web
from services.intent_classifier import classify_intent
from logger import log_chat
from services.qa_agent import ConciergeBot
from services.payment_gateway import (
    create_checkout_session,
    create_addon_checkout_session,
    create_pending_checkout_session,
)

# Illora checkin app / models
from illora.checkin_app.models import Room, Booking, BookingStatus
from illora.checkin_app.pricing import calculate_price_for_room as calculate_price
from illora.checkin_app.database import Base, engine, SessionLocal
from illora.checkin_app.booking_flow import create_booking_record
from illora.checkin_app.chat_models import ChatMessage

from sqlalchemy import func
from sqlalchemy.orm import Session

# ------------------------- Logging -------------------------
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("ai_chieftain")

# ------------------------- FastAPI app -------------------------
app = FastAPI(title="AI Chieftain API", version="1.0.0")

# ------------------------- CORS -------------------------
FRONTEND_ORIGINS = [
    "http://localhost:8080",
    "http://localhost:3000",
    "http://localhost:5173",
    "http://127.0.0.1:5173",
]

# Add CORS middleware to enable cross-origin requests
app.add_middleware(
    CORSMiddleware,
    allow_origins=FRONTEND_ORIGINS,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allow_headers=["*"],
    expose_headers=["*"],
)

# ------------------------- Static files -------------------------
STATIC_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "static")
os.makedirs(STATIC_DIR, exist_ok=True)
app.mount("/static", StaticFiles(directory=STATIC_DIR), name="static")

# ------------------------- Concierge bot -------------------------
bot = ConciergeBot()

# ------------------------- Demo in-memory data -------------------------
DEMO_NAMES = [
    "John Doe", "Jane Smith", "Michael Johnson", "Emily Davis",
    "Daniel Wilson", "Sophia Martinez", "James Brown", "Olivia Taylor",
    "Liam Anderson", "Ava Thomas", "Noah Jackson", "Isabella White",
    "Ethan Harris", "Mia Clark", "Alexander Lewis", "Amelia Hall",
    "William Young", "Charlotte King", "Benjamin Wright", "Harper Scott"
]
DEMO_ROOM_TYPES = ["Deluxe Suite", "Executive Room", "Standard Room", "Presidential Suite"]
sample_bookings: List[Dict[str, Any]] = []


# --- add these imports near the top of your file (if not already present) ---
import requests
import random
from datetime import datetime
from typing import Dict

# Config is already in your project; ensure it's imported:
# from config import Config

# Optional: allow overriding ticket sheet tab name via Config
TICKET_SHEET_NAME = getattr(Config, "GSHEET_TICKET_SHEET", "ticket_management")
GSHEET_WEBAPP_URL = getattr(Config, "GSHEET_WEBAPP_URL", "")
GUEST_LOG_SHEET_NAME = getattr(Config, "GSHEET_GUEST_LOG_SHEET", "guest_interaction_log")

# ------------- Generic helper to push a row to any sheet via your Apps Script Web App -------------
def push_row_to_sheet(sheet_name: str, row_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Call Apps Script webapp with: { action: 'addRow', sheet: sheet_name, rowData: {...} }.
    Returns parsed JSON from webapp or raises on error.
    """
    if not GSHEET_WEBAPP_URL:
        raise RuntimeError("GSHEET_WEBAPP_URL not configured in Config")

    payload = {"action": "addRow", "sheet": sheet_name, "rowData": row_data}
    resp = requests.post(GSHEET_WEBAPP_URL, json=payload, timeout=10)
    resp.raise_for_status()
    try:
        return resp.json()
    except Exception:
        return {"status_code": resp.status_code, "text": resp.text}
    
# ------------- Guest interaction logging helper -------------
def _naive_sentiment(message: str) -> str:
    """Very small sentiment heuristic (optional). Returns 'positive' / 'negative' / ''."""
    if not message:
        return ""
    m = message.lower()
    negative_words = ["not", "no", "never", "bad", "disappointed", "angry", "hate", "worst", "problem", "issue", "delay"]
    positive_words = ["good", "great", "awesome", "excellent", "happy", "love", "enjoy"]
    if any(w in m for w in negative_words) and not any(w in m for w in positive_words):
        return "negative"
    if any(w in m for w in positive_words) and not any(w in m for w in negative_words):
        return "positive"
    return ""

def create_guest_log_row(req_session_id: Optional[str], email: Optional[str], user_input: str, bot_response: str,
                         intent: str, is_guest_flag: bool, ref_ticket_id: Optional[str] = None) -> Dict[str, Any]:
    """
    Build a row matching headers:
    Log ID | Timestamp | Source | Session ID | Guest Email | Guest Name | User Input | Bot Response | Intent | Guest Type | Sentiment | Reference Ticket ID | Conversation URL
    """
    log_id = f"LOG-{random.randint(1000,999999)}"
    timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
    source = "web"
    session_id = req_session_id or ""
    guest_email = email or ""
    guest_name = "Guest"
    user_input_val = user_input or ""
    bot_response_val = bot_response or ""
    intent_val = intent or ""
    guest_type = "guest" if bool(is_guest_flag) else "non-guest"
    sentiment = _naive_sentiment(user_input)
    reference_ticket_id = ref_ticket_id or ""
    conversation_url = ""  # optional â€” left blank or build if you have a UI link

    return {
        "Log ID": log_id,
        "Timestamp": timestamp,
        "Source": source,
        "Session ID": session_id,
        "Guest Email": guest_email,
        "Guest Name": guest_name,
        "User Input": user_input_val,
        "Bot Response": bot_response_val,
        "Intent": intent_val,
        "Guest Type": guest_type,
        "Sentiment": sentiment,
        "Reference Ticket ID": reference_ticket_id,
        "Conversation URL": conversation_url,
    }

# --- Local ticket-detection heuristic ---
def is_ticket_request(message: str, intent: str, addon_matches: list = None) -> bool:
    """
    Return True when message likely requests a service/add-on that should create a ticket.
    Combines intent signals + simple keyword scanning + menu addon hints.
    """
    if not message:
        return False
    lower = message.lower()

    # Strong intents from your classifier that clearly map to service requests
    ticket_intents = {
        "book_addon_spa",
        "book_addon_beverage",
        "book_addon_food",
        "request_service",
        "room_service_request",
        "maintenance_request",
        "order_addon",
        # (add other classifier intent names you use)
    }
    if intent in ticket_intents:
        return True

    # Keyword-based fallback (covers "order a coffee", "please bring towel", "fix ac", etc.)
    keywords = [
        "coffee", "tea", "order", "bring", "deliver", "room service", "food", "meal", "snack",
        "towel", "clean", "housekeeping", "makeup room", "turn down", "repair", "fix", "ac", "wifi",
        "tv", "light", "broken", "leak", "toilet", "bathroom", "shower"
    ]
    if any(k in lower for k in keywords):
        return True

    # If we already matched menu addons (e.g., "club sandwich" matched), that's also a ticket trigger
    if addon_matches and len(addon_matches) > 0:
        return True

    return False

def classify_ticket_category(message: str) -> str:
    """Map message content to a ticket category."""
    m = message.lower()
    if any(w in m for w in ["coffee", "tea", "drink", "food", "meal", "snack", "beverage", "breakfast", "lunch", "dinner"]):
        return "Food"
    if any(w in m for w in ["towel", "clean", "housekeeping", "room service", "bed", "makeup", "turn down", "linen"]):
        return "Room Service"
    if any(w in m for w in ["ac", "wifi", "tv", "light", "repair", "engineer", "fix", "leak", "broken", "toilet", "plumb", "electr"]):
        return "Engineering"
    return "General"

def assign_staff_for_category(category: str) -> str:
    return {
        "Food": "Food Staff",
        "Room Service": "Room Service",
        "Engineering": "Engineering",
        "General": "Front Desk"
    }.get(category, "Front Desk")

def create_ticket_row_payload(message: str, email: str = None) -> Dict[str, str]:
    """
    Build the exact rowData dict matching your sheet's headers:
    Ticket ID | Guest Name | Room No | Request/Query | Category | Assigned To | Status | Created At | Resolved At | Notes
    
    Note: This function now tries to get the actual room number from Client_workflow sheet if possible
    """
    # Get actual room number from Client_workflow sheet if possible
    room_no = "Not Assigned"  # Default value
    if email and GSHEET_WEBAPP_URL:
        try:
            # Query the Client_workflow sheet for user's room
            payload = {
                "action": "getUserData",
                "sheet": "Client_workflow",
                "username": email
            }
            resp = requests.post(GSHEET_WEBAPP_URL, json=payload, timeout=10)
            resp.raise_for_status()
            data = resp.json()
            
            if data.get("found") and data.get("userData"):
                user_data = data.get("userData", {})
                room_alloted = user_data.get("Room Alloted")
                if room_alloted and room_alloted not in ["-", "", "None", "not assigned"]:
                    room_no = room_alloted

        except Exception as e:
            logger.warning(f"Failed to get room number for {email}: {e}")
    
    ticket_id = f"TCK-{random.randint(1000, 99999)}"
    guest_name = email or "Guest"
    category = classify_ticket_category(message)
    assigned_to = assign_staff_for_category(category)
    status = "In Progress"
    created_at = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
    resolved_at = ""  # empty initially
    notes = message

    # Use exact header names present in the spreadsheet (case + spaces matter for the Apps Script mapping)
    # Return the ticket data with the room number
    return {
        "Ticket ID": ticket_id,
        "Guest Name": guest_name,
        "Room No": room_no,  # Now using actual room number from Client_workflow sheet
        "Request/Query": message,
        "Category": category,
        "Assigned To": assigned_to,
        "Status": status,
        "Created At": created_at,
        "Resolved At": resolved_at,
        "Notes": notes
    }

def push_ticket_to_sheet(row_data: Dict[str, str]) -> Dict:
    """
    Call your Apps Script webapp with { action: 'addRow', sheet: <sheetName>, rowData: {...} }.
    Returns the parsed JSON response or raises on network error.
    """
    if not GSHEET_WEBAPP_URL:
        raise RuntimeError("GSHEET_WEBAPP_URL not configured in Config")

    payload = {
        "action": "addRow",
        "sheet": TICKET_SHEET_NAME,
        "rowData": row_data
    }
    try:
        resp = requests.post(GSHEET_WEBAPP_URL, json=payload, timeout=10)
        # Apps Script returns JSON like { success: true, message: 'Row added successfully' }
        try:
            return resp.json()
        except Exception:
            resp.raise_for_status()
            return {"ok": True, "status_code": resp.status_code}
    except Exception as e:
        # bubble up error to caller for graceful logging
        raise

# ------------------------- Helpers -------------------------
def get_db() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def menu_file_path() -> str:
    return os.path.join(os.path.dirname(os.path.abspath(__file__)), "services", "menu.json")

# ------------------------- Startup -------------------------
@app.on_event("startup")
def on_startup():
    try:
        Base.metadata.create_all(bind=engine)
    except Exception as e:
        logger.warning("Failed to create DB tables: %s", e)

    try:
        USER_DB_PATH = "illora_user_gate.db"
        web.init_user_db(USER_DB_PATH)
    except Exception as e:
        logger.warning("Failed to init user DB: %s", e)

    db = SessionLocal()
    try:
        room_count = db.query(func.count(Room.id)).scalar() if db else 0
        if not room_count:
            logger.info("Seeding default rooms...")
            demo_rooms = [
                Room(name="Deluxe King", room_type="deluxe", capacity=2, base_price=5000, total_units=5, media=[]),
                Room(name="Standard Twin", room_type="standard", capacity=2, base_price=3000, total_units=8, media=[]),
                Room(name="Suite Ocean", room_type="suite", capacity=4, base_price=12000, total_units=2, media=[]),
            ]
            db.add_all(demo_rooms)
            db.commit()

        booking_count = db.query(func.count(Booking.id)).scalar()
        if not booking_count:
            first_room = db.query(Room).first()
            demo_booking = Booking(
                guest_name="Demo Guest",
                guest_phone="0000000000",
                room_id=getattr(first_room, "id", None),
                check_in=date.today(),
                check_out=(date.today() + timedelta(days=1)),
                price=getattr(first_room, "base_price", 0),
                channel="seed",
                channel_user="demo@example.com",
            )
            db.add(demo_booking)
            db.commit()

        chat_exists = db.query(func.count(ChatMessage.session_id)).scalar() if hasattr(ChatMessage, "session_id") else 0
        if not chat_exists:
            cm_user = ChatMessage(
                session_id="seed-session", email="demo@example.com", channel="web",
                role="user", text="Hi, is breakfast included?", intent="ask_breakfast", is_guest=True
            )
            cm_bot = ChatMessage(
                session_id="seed-session", email="demo@example.com", channel="web",
                role="assistant", text="Breakfast is included for bookings with breakfast plan.",
                intent="reply", is_guest=True
            )
            db.add_all([cm_user, cm_bot])
            db.commit()
    except Exception as e:
        logger.warning("Startup seeding error: %s", e)
        db.rollback()
    finally:
        db.close()

    global sample_bookings
    sample_bookings = []
    base_date = datetime.today()
    for i, name in enumerate(DEMO_NAMES, start=1):
        check_in = base_date + timedelta(days=random.randint(0, 10))
        check_out = check_in + timedelta(days=random.randint(1, 5))
        sample_bookings.append({
            "id": i,
            "guest": name,
            "room_no": random.randint(1, 100),
            "room": random.choice(DEMO_ROOM_TYPES),
            "check_in": check_in.strftime("%Y-%m-%d"),
            "check_out": check_out.strftime("%Y-%m-%d"),
            "status": random.choice(["Confirmed", "Checked-in", "Checked-out", "Cancelled"]),
            "amount": random.randint(5000, 20000)
        })

# ------------------------- SSE Broker -------------------------
class EventBroker:
    def __init__(self):
        self.connections: List[asyncio.Queue] = []

    async def connect(self) -> asyncio.Queue:
        q: asyncio.Queue = asyncio.Queue()
        self.connections.append(q)
        return q

    async def disconnect(self, q: asyncio.Queue):
        if q in self.connections:
            try:
                self.connections.remove(q)
            except Exception:
                pass

    async def broadcast(self, event: str, data: Dict[str, Any]):
        msg = json.dumps({"event": event, "data": data}, default=str)
        for q in list(self.connections):
            try:
                await q.put(msg)
            except Exception:
                try:
                    self.connections.remove(q)
                except Exception:
                    pass

broker = EventBroker()

@app.get("/events")
async def sse_events(request: Request):
    async def event_generator(q: asyncio.Queue):
        try:
            await q.put(json.dumps({"event": "connected", "data": {}}))
            while True:
                if await request.is_disconnected():
                    break
                msg = await q.get()
                yield f"data: {msg}\n\n"
        finally:
            await broker.disconnect(q)

    q = await broker.connect()
    headers = {"Cache-Control": "no-cache", "X-Accel-Buffering": "no"}
    return StreamingResponse(event_generator(q), headers=headers, media_type="text/event-stream")

# ------------------------- Pydantic Models -------------------------
class LoginReq(BaseModel):
    email: str
    password: str
    remember: bool = True

class ChatReq(BaseModel):
    message: str
    is_guest: Optional[bool] = False
    session_id: Optional[str] = None
    email: Optional[str] = None

class ChatActions(BaseModel):
    show_booking_form: bool = False
    addons: List[str] = Field(default_factory=list)
    payment_link: Optional[str] = None
    pending_balance: Optional[Dict[str, Any]] = None

class ChatResp(BaseModel):
    reply: str
    reply_parts: Optional[List[str]] = None
    intent: Optional[str] = None
    actions: ChatActions = Field(default_factory=ChatActions)

class BookingStageReq(BaseModel):
    room_id: int
    check_in: date
    check_out: date
    guest_name: str
    guest_phone: Optional[str] = None

class BookingConfirmReq(BaseModel):
    booking_id: str
    room_type: str
    nights: int
    cash: bool = False
    extras: List[str] = Field(default_factory=list)

class BookingForm(BaseModel):
    check_in: date
    check_out: date
    guests: int
    preferences: Optional[str] = ""
    whatsapp_number: Optional[str] = ""

class DemoBookingUpdate(BaseModel):
    guest: Optional[str] = None
    room: Optional[str] = None
    check_in: Optional[str] = None
    check_out: Optional[str] = None
    status: Optional[str] = None
    amount: Optional[int] = None

class DBBookingUpdate(BaseModel):
    guest_name: Optional[str] = None
    guest_phone: Optional[str] = None
    room_id: Optional[int] = None
    check_in: Optional[date] = None
    check_out: Optional[date] = None
    price: Optional[float] = None
    status: Optional[str] = None  # e.g., "CONFIRMED", "CHECKED_IN", etc.

# ------------------------- Demo endpoints -------------------------
@app.get("/demo/bookings/all")
def demo_get_all_bookings():
    return {"bookings": sample_bookings}

@app.get("/demo/bookings/{booking_id}")
def demo_get_booking(booking_id: int):
    for b in sample_bookings:
        if b["id"] == booking_id:
            return b
    raise HTTPException(status_code=404, detail="Demo booking not found")

@app.patch("/demo/bookings/{booking_id}")
def demo_update_booking(booking_id: int, patch: DemoBookingUpdate):
    for b in sample_bookings:
        if b["id"] == booking_id:
            for field, value in patch.dict(exclude_unset=True).items():
                b[field] = value
            return {"ok": True, "booking": b}
    raise HTTPException(status_code=404, detail="Demo booking not found")

@app.post("/admin/seed")
def admin_seed_demo(count: int = Query(20, ge=1, le=100)):
    global sample_bookings
    sample_bookings = []
    base_date = datetime.today()
    for i in range(count):
        name = random.choice(DEMO_NAMES)
        check_in = base_date + timedelta(days=random.randint(0, 10))
        check_out = check_in + timedelta(days=random.randint(1, 5))
        sample_bookings.append({
            "id": i + 1,
            "guest": name,
            "room": random.choice(DEMO_ROOM_TYPES),
            "check_in": check_in.strftime("%Y-%m-%d"),
            "check_out": check_out.strftime("%Y-%m-%d"),
            "status": random.choice(["Confirmed", "Checked-in", "Checked-out", "Cancelled"]),
            "amount": random.randint(5000, 20000)
        })
    return {"ok": True, "seeded": len(sample_bookings)}




# ---------------- Auth Models -------------------------
class SignupReq(BaseModel):
    name: str = Field(..., min_length=2, description="User's full name")
    username: str = Field(..., min_length=3, description="User's email address")
    password: str = Field(..., min_length=6, description="User's password")
    phoneNo: str = Field(default="", description="User's phone number")
    
class LoginReq(BaseModel):
    username: str = Field(..., description="User's username/email")
    password: str = Field(..., description="User's password")
    remember: bool = Field(default=True, description="Remember me flag")

class UpdateWorkflowReq(BaseModel):
    username: str = Field(..., description="User's username/email")
    stage: str = Field(..., description="New workflow stage")
    booking_id: Optional[str] = Field(None, description="Booking ID if available")
    id_proof_link: Optional[str] = Field(None, description="ID proof link if available")

# ---------------- Auth endpoints ----------------
@app.post("/auth/signup", tags=["authentication"])
async def signup(req: SignupReq = Body(...)):
    """
    Register a new user and add them to the Client_workflow sheet
    """
    logger.info(f"Received signup request for username: {req.username}")
    
    try:
        # Generate unique Client Id (e.g., ILR-YYYY-XXXX)
        client_id = f"ILR-{datetime.utcnow().year}-{random.randint(1000,9999)}"
        workflow_stage = "Registered"
        
        # Prepare row data for Client_workflow sheet
        row_data = {
            "Client Id": client_id,
            "Name": req.name,
            "Email": req.username,  # Map username to Email column
            "Password": req.password,
            "Booking Id": "",
            "Workflow Stage": workflow_stage,  # Fixed typo in key name
            "Room Alloted": "",
            "CheckIn": "",
            "Check Out": "",
            "Id Link": "",
        }
        
        # Add user to Google Sheet
        resp = push_row_to_sheet("Client_workflow", row_data)
        
        if resp.get("success") or resp.get("ok") or resp.get("status_code") == 200:
            logger.info(f"User {req.username} registered successfully with client ID {client_id}")
            return {
                "success": True,
                "workflowStage": workflow_stage,
                "clientId": client_id,
                "message": "Registration successful"
            }
        else:
            error_msg = resp.get("message", "Unknown error during registration")
            logger.error(f"Failed to register user {req.username}: {error_msg}")
            raise HTTPException(status_code=400, detail=error_msg)
            
    except Exception as e:
        logger.error(f"Error in signup endpoint: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/auth/login", tags=["authentication"])
async def login(req: LoginReq):
    """Verify user credentials against the Google Sheet"""
    logger.info(f"Login attempt for username: {req.username}")
    
    try:
        # Prepare payload for Google Sheet verification
        payload = {
            "action": "verifyUser",
            "sheet": "Client_workflow",
            "username": req.username,  # Will be treated as email in Apps Script
            "password": req.password
        }
        
        logger.info("Sending verification request to Google Sheet")
        resp = requests.post(Config.GSHEET_WEBAPP_URL, json=payload, timeout=10)
        resp.raise_for_status()
        
        data = resp.json()
        logger.info(f"Received response from Google Sheet: {data}")
        
        if "error" in data:
            logger.error(f"Error from Google Sheet: {data['error']}")
            raise HTTPException(status_code=401, detail=data["error"])
            
        found = data.get("found", False)
        verified = data.get("verified", False)
        user_data = data.get("userData")
        message = data.get("message", "Unknown error")
        
        if not found:
            logger.warning(f"User {req.username} not found")
            raise HTTPException(
                status_code=403,
                detail={
                    "message": "User not registered. Please sign up first.",
                    "needsSignup": True
                }
            )
        
        if not verified:
            logger.warning(f"Invalid password for user {req.username}")
            raise HTTPException(
                status_code=401,
                detail={
                    "message": message or "Invalid credentials"
                }
            )
        
        # Generate remember token if requested
        token = uuid.uuid4().hex if req.remember else None
        
        logger.info(f"User {req.username} logged in successfully")
        return {
            "username": req.username,
            "remember_token": token,
            "userData": user_data
        }
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Login error: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

# Model for session restoration
class RestoreSessionReq(BaseModel):
    username: str = Field(..., description="User's username/email")

@app.post("/auth/me", tags=["authentication"])
async def restore_session(req: RestoreSessionReq):
    """Fetch user data from Google Sheet for session restoration"""
    logger.info(f"Restoring session for username: {req.username}")
    
    try:
        # Prepare payload for Google Sheet
        payload = {
            "action": "getUserData",
            "sheet": "Client_workflow",
            "username": req.username,
        }
        
        logger.info("Sending user data request to Google Sheet")
        resp = requests.post(Config.GSHEET_WEBAPP_URL, json=payload, timeout=10)
        resp.raise_for_status()
        
        data = resp.json()
        logger.info(f"Received response from Google Sheet: {data}")
        
        if "error" in data:
            logger.error(f"Error from Google Sheet: {data['error']}")
            raise HTTPException(status_code=401, detail=data["error"])
            
        found = data.get("found", False)
        user_data = data.get("userData")
        
        if not found or not user_data:
            logger.warning(f"User {req.username} not found")
            raise HTTPException(status_code=404, detail="User not found")
        
        logger.info(f"Successfully restored session for {req.username}")
        return {
            "username": req.username,
            "userData": user_data
        }
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error restoring session: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/auth/update-workflow", tags=["authentication"])
async def update_workflow(req: UpdateWorkflowReq):
    """Update a user's workflow stage in the Client_workflow sheet"""
    logger.info(f"Updating workflow stage for user {req.username} to {req.stage}")
    
    try:
        # Prepare payload for Google Sheet update
        update_data = {
            "action": "updateUserWorkflow",
            "sheet": "Client_workflow",
            "email": req.username,
            "updates": {
                "Workflow Stage": req.stage
            }
        }
        
        # Add optional fields if provided
        if req.booking_id:
            update_data["updates"]["Booking Id"] = req.booking_id
        if req.id_proof_link:
            update_data["updates"]["Id Link"] = req.id_proof_link
            
        logger.info("Sending update request to Google Sheet")
        resp = requests.post(Config.GSHEET_WEBAPP_URL, json=update_data, timeout=10)
        resp.raise_for_status()
        
        data = resp.json()
        logger.info(f"Received response from Google Sheet: {data}")
        
        if "error" in data:
            logger.error(f"Error from Google Sheet: {data['error']}")
            raise HTTPException(status_code=400, detail=data["error"])
            
        logger.info(f"Successfully updated workflow stage for user {req.username}")
        return {
            "success": True,
            "message": f"Workflow stage updated to {req.stage}",
            "userData": data.get("userData")
        }
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error updating workflow: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


# ---------------- Chat endpoint ----------------
# -------------------- Updated /chat endpoint (drop-in replacement) --------------------
@app.post("/chat", response_model=ChatResp)
async def chat(req: ChatReq):
    user_input = req.message or ""
    is_guest = bool(req.is_guest)
    # keep original behavior for bot.ask (minimal changes)
    bot_reply_text = bot.ask(user_input, user_type=is_guest)
    intent = classify_intent(user_input)
    actions = ChatActions()

    # --- menu/extras logic unchanged (but portable path usage) ---
    MENU_FILE = menu_file_path()
    try:
        with open(MENU_FILE, "r", encoding="utf-8") as f:
            MENU = json.load(f)
    except FileNotFoundError:
        MENU = {}

    AVAILABLE_EXTRAS = {}
    EXTRAS_PRICE_BY_KEY = {}
    for category, items in MENU.items():
        if category == "complimentary":
            continue
        for display_name, _price in items.items():
            label = display_name.replace("_", " ").title()
            key = display_name.lower().replace(" ", "_")
            AVAILABLE_EXTRAS[label] = key
            EXTRAS_PRICE_BY_KEY[key] = _price

    message_lower = user_input.lower()
    addon_matches = [k for k in AVAILABLE_EXTRAS if k.lower() in message_lower]

    # ------------------ Ticket creation (if detected) ------------------
    created_ticket_id: Optional[str] = None
    try:
        if is_ticket_request(user_input, intent, addon_matches):
            ticket_row = create_ticket_row_payload(user_input, req.email)
            try:
                resp_json = push_row_to_sheet(TICKET_SHEET_NAME, ticket_row)
                created_ticket_id = ticket_row.get("Ticket ID")
                logger.info("Ticket created: %s (sheet resp: %s)", created_ticket_id, resp_json)
                # broadcast ticket_created SSE event (best-effort)
                # Broadcast ticket created event
                try:
                    await broker.broadcast("ticket_created", {
                        "ticket_id": created_ticket_id,
                        "guest_email": req.email,
                        "room_no": ticket_row.get("Room No"),
                        "category": ticket_row.get("Category"),
                        "assigned_to": ticket_row.get("Assigned To"),
                        "status": ticket_row.get("Status"),
                        "created_at": ticket_row.get("Created At"),
                        "notes": ticket_row.get("Notes"),
                    })
                except Exception as e:
                    logger.warning(f"Failed to broadcast ticket creation: {e}")
            except Exception as e:
                logger.warning("Failed to push ticket to sheet: %s", e)
    except Exception as e:
        logger.warning("Ticket subsystem error: %s", e)

    # ------------------ booking form logic (HARD-CODED keyword check) ------------------
    # Only show booking form when user explicitly asks to book/reserve a room (keyword-based).
    booking_keywords = ["book a room", "book room", "book", "reserve", "reservation", "room availability"]
    if any(kw in message_lower for kw in booking_keywords):
        actions.show_booking_form = True
    # (We intentionally removed reliance on generic "payment_request" to show forms)

    # ------------------ addon checkout logic (kept as-is) ------------------
    if intent in ('book_addon_spa', 'book_addon_beverage', 'book_addon_food'):
        actions.addons = addon_matches
        try:
            checkout_url = create_addon_checkout_session(
                session_id=req.session_id or str(uuid.uuid4()),
                extras=[AVAILABLE_EXTRAS[k] for k in addon_matches]
            )
            actions.payment_link = checkout_url
        except Exception as e:
            logger.warning("create_addon_checkout_session failed: %s", e)
            actions.payment_link = None

    # NOTE: removed the old "if intent == 'checkout_balance':" payment flow replacement was requested.
    # If you still want pending-balance support via web.get_due_items_details, add a distinct keyword or endpoint.

    # file-based log (keep existing)
    log_chat("web", req.session_id or "", user_input, bot_reply_text, intent, is_guest)

    # ------------------ append guest interaction log to sheet ------------------
    try:
        log_row = create_guest_log_row(req.session_id, req.email, user_input, bot_reply_text, intent, is_guest, created_ticket_id)
        try:
            resp_log = push_row_to_sheet(GUEST_LOG_SHEET_NAME, log_row)
            logger.info("Guest interaction logged to sheet (Log ID=%s): %s", log_row.get("Log ID"), resp_log)
            # optionally broadcast a guest_log_created SSE event
            # Broadcast guest log event
            try:
                await broker.broadcast("guest_log_created", {
                    "log_id": log_row.get("Log ID"),
                    "session_id": log_row.get("Session ID"),
                    "guest_email": log_row.get("Guest Email"),
                    "intent": intent,
                    "ticket_ref": created_ticket_id,
                    "timestamp": log_row.get("Timestamp")
                })
            except Exception as e:
                logger.warning(f"Failed to broadcast guest log: {e}")
        except Exception as e:
            logger.warning("Failed to push guest log to sheet: %s", e)
    except Exception as e:
        logger.warning("Guest log subsystem error: %s", e)

    # ------------------ persist to DB and broadcast (unchanged) ------------------
    db = SessionLocal()
    try:
        cm_user = ChatMessage(
            session_id=req.session_id,
            email=req.email,
            channel="web",
            role="user",
            text=user_input,
            intent=intent,
            is_guest=is_guest
        )
        db.add(cm_user)
        db.commit(); db.refresh(cm_user)

        cm_bot = ChatMessage(
            session_id=req.session_id,
            email=req.email,
            channel="web",
            role="assistant",
            text=bot_reply_text,
            intent=intent,
            is_guest=is_guest
        )
        db.add(cm_bot)
        db.commit(); db.refresh(cm_bot)

        # broadcast chat_message
            # Broadcast chat message
            try:
                await broker.broadcast("chat_message", {
                    "session_id": req.session_id,
                    "email": req.email,
                    "user": cm_user.text,
                    "assistant": cm_bot.text,
                    "intent": intent
                })
            except Exception as e:
                logger.warning(f"Failed to broadcast chat message: {e}")    except Exception as e:
        logger.warning("Failed to persist chat message: %s", e)
        db.rollback()
    finally:
        db.close()

    reply_parts = bot_reply_text.split("\n\n")
    return ChatResp(reply=bot_reply_text, reply_parts=reply_parts, intent=intent, actions=actions)

# ---------------- Add-ons ----------------
@app.get("/addons/catalog")
def addons_catalog():
    MENU_FILE = menu_file_path()
    try:
        with open(MENU_FILE, "r", encoding="utf-8") as f:
            MENU = json.load(f)
    except FileNotFoundError:
        MENU = {}

    AVAILABLE_EXTRAS = {}
    EXTRAS_PRICE_BY_KEY = {}
    for category, items in MENU.items():
        if category == "complimentary":
            continue
        for display_name, _price in items.items():
            label = display_name.replace("_", " ").title()
            key = display_name.lower().replace(" ", "_")
            AVAILABLE_EXTRAS[label] = key
            EXTRAS_PRICE_BY_KEY[key] = _price

    catalog = [{"key": k, "label": k.replace("_", " ").title(), "price": EXTRAS_PRICE_BY_KEY.get(k)} for k in AVAILABLE_EXTRAS.values()]
    return {"catalog": catalog}

@app.post("/addons/tab")
def addons_tab(email: str, keys: List[str]):
    added = web.add_due_items(email, keys)
    total = web.due_total_from_items(web.get_due_items(email))
    return {"added": bool(added), "pending_total": total}

@app.post("/addons/checkout")
def addons_checkout(session_id: str, extras: List[str]):
    url = create_addon_checkout_session(session_id=session_id, extras=extras)
    return {"checkout_url": url}


# ---------------- Rooms / pricing ----------------
@app.get("/rooms")
def rooms(check_in: date = Query(...), check_out: date = Query(...), db: Session = Depends(get_db)):
    rooms = db.query(Room).all()
    out = []

    for r in rooms:
        try:
            price, nights = calculate_price(db=db, room=r, check_in=check_in, check_out=check_out)
        except Exception:
            price, nights = r.base_price, 1
        out.append({
            "id": r.id,
            "name": r.name,
            "room_type": r.room_type,
            "capacity": r.capacity,
            "media": r.media,
            "quote": {"price": price, "nights": nights}
        })
    return {"rooms": out}


# ---------------- Booking form endpoint (frontend sends form) ----------------
@app.post("/booking/form")
def booking_form(form: BookingForm, db: Session = Depends(get_db)):
    rooms_out: List[Dict[str, Any]] = []
    rooms = db.query(Room).all()
    if not rooms:
        return {"rooms": [], "message": "No rooms found in DB. Seed rooms first."}

    ci = form.check_in
    co = form.check_out
    for r in rooms:
        try:
            price, nights = calculate_price(db=db, room=r, check_in=ci, check_out=co)
        except Exception:
            price, nights = r.base_price, 1

        rooms_out.append({
            "id": r.id,
            "name": r.name,
            "room_type": r.room_type,
            "capacity": r.capacity,
            "units": getattr(r, "total_units", None),
            "media": r.media or [],
            "price": price,
            "nights": nights,
            "base_price": getattr(r, "base_price", None),
        })

    return {"rooms": rooms_out, "check_in": form.check_in.isoformat(), "check_out": form.check_out.isoformat(), "guests": form.guests, "preferences": form.preferences or "", "whatsapp_number": form.whatsapp_number or ""}


# ---------------- Bookings (DB-backed) ----------------
@app.post("/bookings/stage")
async def bookings_stage(req: BookingStageReq, email: Optional[str] = Query(None)):
    db = SessionLocal()
    try:
        booking = None
        try:
            booking = create_booking_record(
                db=db,
                guest_name=req.guest_name,
                guest_phone=req.guest_phone,
                room_id=req.room_id,
                check_in=req.check_in,
                check_out=req.check_out,
                price=0,
                channel='web',
                channel_user=email
            )
        except Exception as e:
            logger.warning("create_booking_record error: %s", e)

        if booking is None:
            fallback = Booking(
                guest_name=req.guest_name,
                guest_phone=req.guest_phone,
                room_id=req.room_id,
                check_in=req.check_in,
                check_out=req.check_out,
                price=0,
                channel='web',
                channel_user=email
            )
            db.add(fallback)
            db.commit()
            db.refresh(fallback)
            booking = fallback

        booking_id = str(getattr(booking, "id"))
        try:
            await broker.broadcast("booking_created", {"booking_id": booking_id})
        except Exception:
            pass

        return {"booking_id": booking_id}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Failed to stage booking: {e}")
    finally:
        db.close()

@app.post("/bookings/confirm")
async def bookings_confirm(req: BookingConfirmReq):
    db = SessionLocal()
    try:
        booking = None
        try:
            booking = db.query(Booking).filter(Booking.id == int(req.booking_id)).first()
        except Exception:
            booking = db.query(Booking).filter(Booking.id == req.booking_id).first()

        if not booking:
            raise HTTPException(status_code=404, detail="Staged booking not found")

        canonical_booking_id = str(getattr(booking, "id"))
        stripe_sess = create_checkout_session(session_id=canonical_booking_id, room_type=req.room_type, nights=req.nights, cash=req.cash, extras=req.extras)

        if isinstance(stripe_sess, dict):
            stripe_id = stripe_sess.get("id")
            checkout_url = web._checkout_url_from_session(stripe_sess)
        else:
            stripe_id = getattr(stripe_sess, "id", None)
            checkout_url = web._checkout_url_from_session(stripe_sess)

        if hasattr(booking, "stripe_session_id"):
            booking.stripe_session_id = stripe_id
        if hasattr(booking, "checkout_url"):
            booking.checkout_url = checkout_url

        db.add(booking)
        db.commit()
        db.refresh(booking)

        try:
            qr_local, qr_public = web.save_qr_to_static(checkout_url, f"checkout_{canonical_booking_id}.png")
        except Exception:
            qr_public = None

        try:
            await broker.broadcast("booking_confirmed", {
                "booking_id": canonical_booking_id,
                "stripe_session_id": stripe_id,
                "checkout_url": checkout_url
            })
        except Exception:
            pass

        return {"checkout_url": checkout_url, "qr_url": qr_public, "stripe_session_id": stripe_id}
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Failed to confirm booking: {e}")
    finally:
        db.close()

@app.get("/bookings/{booking_id}")
def get_booking_db(booking_id: str):
    db = SessionLocal()
    try:
        # try numeric id first
        try:
            b = db.query(Booking).filter(Booking.id == int(booking_id)).first()
        except Exception:
            b = db.query(Booking).filter(Booking.id == booking_id).first()

        if not b:
            raise HTTPException(status_code=404, detail="Booking not found")

        return {
            "booking_id": b.id,
            "guest_name": getattr(b, "guest_name", None),
            "guest_phone": getattr(b, "guest_phone", None),
            "room_id": getattr(b, "room_id", None),
            "check_in": getattr(b, "check_in", None).isoformat() if getattr(b, "check_in", None) else None,
            "check_out": getattr(b, "check_out", None).isoformat() if getattr(b, "check_out", None) else None,
            "price": getattr(b, "price", None),
            "status": getattr(b, "status", None).name if getattr(b, "status", None) else None,
            "stripe_session_id": getattr(b, "stripe_session_id", None) if hasattr(b, "stripe_session_id") else None,
        }
    finally:
        db.close()

@app.get("/bookings/all_db")
def get_all_bookings_db():
    db = SessionLocal()
    try:
        rows = db.query(Booking).all()
        out = []
        for b in rows:
            out.append({
                "id": getattr(b, "id", None),
                "guest_name": getattr(b, "guest_name", None),
                "room_id": getattr(b, "room_id", None),
                "check_in": getattr(b, "check_in", None).isoformat() if getattr(b, "check_in", None) else None,
                "check_out": getattr(b, "check_out", None).isoformat() if getattr(b, "check_out", None) else None,
                "price": getattr(b, "price", None),
                "status": getattr(b, "status", None).name if getattr(b, "status", None) else None,
            })
        return {"bookings": out}
    finally:
        db.close()

@app.patch("/bookings/{booking_id}/update")
def bookings_update(booking_id: str, patch: DBBookingUpdate):
    db = SessionLocal()
    try:
        try:
            b = db.query(Booking).filter(Booking.id == int(booking_id)).first()
        except Exception:
            b = db.query(Booking).filter(Booking.id == booking_id).first()

        if not b:
            raise HTTPException(status_code=404, detail="Booking not found")

        for field, val in patch.dict(exclude_unset=True).items():
            if field == "status" and val:
                # try to set Enum safely, attempt different casing strategies
                try:
                    if isinstance(val, str) and val.upper() in BookingStatus.__members__:
                        setattr(b, "status", BookingStatus[val.upper()])
                    elif hasattr(BookingStatus, val):
                        setattr(b, "status", getattr(BookingStatus, val))
                    else:
                        # fallback: leave as-is or raise
                        raise ValueError(f"Invalid status: {val}")
                except Exception as e:
                    raise HTTPException(status_code=400, detail=str(e))
            else:
                setattr(b, field, val)

        db.add(b)
        db.commit(); db.refresh(b)

        # broadcast update (best-effort)
        try:
            asyncio.create_task(broker.broadcast("booking_updated", {
                "id": getattr(b, "id"),
                "guest_name": getattr(b, "guest_name", None),
                "status": getattr(b, "status", None).name if getattr(b, "status", None) else None,
                "price": getattr(b, "price", None),
            }))
        except RuntimeError:
            pass

        return {"ok": True}
    finally:
        db.close()


# ---------------- Billing ----------------
@app.get("/billing/due-items")
def billing_due(email: str):
    details, total = web.get_due_items_details(email)
    return {"items": details, "total": total}

@app.post("/billing/checkout")
def billing_checkout(amount: int):
    sess = create_pending_checkout_session(amount)
    url = web._checkout_url_from_session(sess)
    return {"checkout_url": url}


# ---------------- ID-proof upload ----------------
@app.post("/users/{email}/id_proof")
def id_proof(email: str, file: UploadFile = File(...)):
    url = web.save_id_proof(email, file)
    USER_DB_PATH = "illora_user_gate.db"
    web.set_id_proof(email, 1, USER_DB_PATH)
    return {"url": url}


@app.get("/health")
def health():
    return {"ok": True, "timestamp": datetime.utcnow().isoformat()}

# ------------------------- Run locally -------------------------
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=int(os.environ.get("PORT", 8000)), reload=True)
